# 修改记录

版本号    |日期            | 更改理由
----------|----------------|----------------
V1.0      | 2023-09-19     | MD化




# 文档约定
+ 一级标题前使用三个空行




# 总则

**仅总结一些常用且实用的编程规范和技巧，且避免记忆负担，聚焦影响比较大的20% !**

# 术语

          |说明            
------------ |---------------------------------
开发目录     | IDE开发环境所设定的编码目录
SVN工作目录  | 利用`SVN`客户端工具与`SVN`服务器交互的工具，或可以简单认为含有`.svn`隐藏子目录的目录



# 两种工作方式
+ SVN工作目录直接作为开发目录
+ 开发目录与SVN work copy目录独立

## 推荐SVN工作目录直接作为开发目录
+ 省去非冲突代码的人工合并操作，而且由算法保证的合并正确性
+ 减少不必要的目录切换，例如，`svn log`、`svn revert`代码回退等

> 换句话说，SVN工作目录直接作为开发目录，将集成了`svn`所有工具箱，包括可以常用的操作集成到**右键菜单**中

## 为什么非冲突代码合并以算法化

对于非冲突的代码，即使是人工合并，一般只要不冲突的代码都是直接合并，而这点不必要的人工耗费是可以充分被`svn`工具算法化的。

> 如果需要代码走查，可以独立地采取其它方式，后面文档另有建议

## 冲突代码人工合并过程

+ 或覆盖
+ 或自己代码在别人冲突代码前
+ 或别人冲突代码在自己代码前

> 对于人工的这种行为，SVN解决冲突工具对其充分地具象化了



# 工作原则
在SVN工作目录可以使用众多SVN辅助工具。

如果大量使用SVN工具，则会默认地要求一种优良的代码提交原则：

> 尽量原子化地提交代码变动

> 原子提交在跟踪代码变动、代码走查、回退撤销代码、跨分支间合并代码，以及提交日志描述准确性等各方面非常有利



# SVN工具箱

## Commit
在SVN工作目录进行提交动作，则可以发现变化文件列表，省去用代码文件比对工具发现改动的文件的操作。而且，如果文件被意外修改，则可以直接使用文件右键菜单中的`SVN Revert`工具，将文件直接回退掉。

### Ignore-on-commit

SVN工作目录作为代码开发目录后，可能会遇到某些本地调试，或测试相关的本地变动文件，并不需要提交到SVN上，可以在commit提交时的文件列表中，选中文件，弹出右键菜单，选用`Move to changelist”-->“ignore-on-commit`，将这类文件归类到不需要提交的changelist中，将其单独分门别类，避免混在在一起被误提交到SVN系统。

### Restore after commit

极端地，在更非常少的场合下，本地不需要提交文件，还是会存在某些这些文件内的代码行级别的变动，需要合并到SVN上，但是又想保留本地不需要提交到SVN的修改。

针对这种情况，我们可以在提交这个文件时，先用`Restore after commit`对文件打上标记，然后利用右键菜单中`Compare with base`，将本地不需要提交到SVN代码先覆盖掉，仅保留需要提交到SVN的变动代码后，特别地勾选提交的文件的复选框，将此特殊文件内某些行的变动提交到SVN上。

在完成Commit提交后，您将发现，本地不需要提交的修改和需要提交的修改，神奇地共存在一起，保持打标签时的文件状态，完美！


## Revert

根据回退操作对象，分为目录和文件。
大多数情况，我们会在目录或文件上结合`SVN Log`日志，将目录或文件回退到某一历史版本，或者回退撤销某次commit的变动；或者会对文件直接`Revert`掉意外修改。

### Revert to this revision

 可以将目录下文件或者单个文件的修改回退到某一历史版本，例如，Build\*时的代码状态。但是，在工作目录`SVN Log`时，展现的工作目录revision版本状态是不变化的。
 如果希望在工作目录通过svn log查看revision状态也发生变化，则建议使用`update item to this revision`操作。

### Revert changes from this revisions

通过多选提交日志，可以进行批量`Revert changes from this revision`，这样就可以将某次制作版本时，发现的未成熟的代码提交，给批量回退撤销掉，而不用手工实施。

> 注意，撤销后，需要commit提交变动，才能反馈到SVN中。

另外，特别地，通过SVN提交日志，可以进行反反撤销。在发布版本后，如果想恢复不成熟的代码，继续修改修改，则可以再对撤销Revsion执行`Revert changes from this revision`，就可以将不成熟的代码恢复出来，也不需要太多手工操作。


## Log

### 查看工作目录更新版本

在工作目录顶层目录打开`SVN Log`，在弹出窗口的黑色字体的revision即为工作目录的版本状态。

### 通过日志比较操作

在SVN提交日志上，我们经常可以进行“Revert”和“Compare revisions”。特别地，对于比较操作，是很好的、可以作为替代方式的代码走查。

> 注意： SVN日志在文件被删除、重命名等场合将丢失日志记录，所以，应尽量避免文件的此类操作。

### 基于某revision检出代码

在svn顶级目录打开svn log，然后从svn log中选中某revision后，右键弹出菜单，选择“Update item to revision”，即可将代码更新到某一版本状态，例如，按照Build版本号的revision进行更新。

#### 基于某revision检出代码合入某些变更

在工作目录顶层，在检出代码基础上，可以在svn log上选中部分revision或者在顶部过滤输入栏输入某些关键词，将某些revision选中，弹出右键菜单，选择“Merge revision to ...”操作，在弹出窗口内，选择工作目录的顶层目录，，点击确定即可将变更代码merge过来。


## Compare

### 与previous revision对比
选中某文件可以选择与历史前一个变更版本比较

### 任意不同revision间对比
通过文件或目录的`SVN Log`任意选择两次revision进行对比

### 任意revision与working copy对比

操作对象依然是目录或文件，通过“SVN Log”选中任意单条提交revision，可以选择“Compare with working copy”进行变更对比，这对于比较修改代码与不同阶段的差异，很有帮助，可以看出更长时间跨度的演变。
特别地，针对于目录的此种操作，可以批量比较文件，有兴趣的可以试试。


## Blame

如果想追踪代码的变动，最早什么时候引入的修改，则可以通过“SVN Blame ...”操作跟踪到最初的一次变化，包括日期、 人员，以及log。

主要操作由两种：
+ 鼠标浮动到左侧边观察某一行的提交日志
+ 继续往前一版本追踪时，选中一行后右键选择“Blame previous revision”

> SVN提供代码行追踪方式，可以减轻一部分开发人员不愿意写注释的心理压力。因为，通过SVN代码Blame总可以发现谁引入的修改，区别只在于写没写明原因，以利于提示后来人维护。