
# 场景
今天遇到一个实例，解决了以前的疑问:~~在一个旧平台上编译的程序，而部署在另外一个跨版本平台上运行会不会存在问题？~~

> 在旧平台上编译程序，实际上更多地是为了保持编译器的不变，以避免升级编译器后，需要大量修订已有代码的编译错误问题

以前总隐隐觉得此种交叉编译、部署模式会存在问题，但却举不出一个举例的例子来进行说明。最近，幸而得之:)

# 以前经验
因为过往，项目已多次这样跨`CentOS`版本进行交叉编译和分开部署，而没有在实践中遇到比较明显的问题...

遂事后诸葛亮来总结经验，毕竟产品代码基本上仅依赖`glibc`等基本库，而`glibc`的API保持了比较好的接口兼容性，
所以，这样在旧平台上编译，而部署在比较新的平台上运行，问题并不是很大。

但，当应用复杂到一定程度，随着依赖的增多，则问题就会冒出来！

# 具体问题
首先，在我们的应用中，需要使用到`sftp`组件进行上传、下载相关文件，所以，将`sftp`组件API动态库集成在产品中进行捆绑，而且长期不升级组件库，以利于保持已开发代码的稳定性。但，此种组件策略会导致一些隐患，后续将逐渐分析到。

其实事后分析来看，由此引入`sftp`组件开始，实际上应用在启动时使用`LD_LIBRARY_PATH`环境变量，控制相关依赖的加载，建立了一个加载依赖的小环境！


再者，应用为了操作`shell`方便，以及读取`shell`的输出，应用启动了一个伺服子进程，并通过`exec`替换为`bash`程序映像，以交互模式运行应用需要执行的脚本。

应用在开了`shell`通道的口子后，实际上这里要求的依赖环境，远比以前的`sftp`应用小环境要大很多。因为`shell`可以运行很多系统命令，而这些庞杂的系统命令的依赖环境，可能与此小环境存在冲突。因为应用借助`LD_LIBRARY_PATH`环境变量控制依赖加载，首先加载的是私有路径下的依赖！

在最近遇到的情况中，在`shell`子进程中使用`curl`遭遇到符号查找不到的运行时错误，而且`$?`命令返回错误码*127*

```c
curl: symbol lookup error: /lib64/libk5crypto.so.3: undefined symbol: EVP_KDF_ctrl, version OPENSSL ...

```

> 对比来看，手工在终端中执行类似的脚本逻辑并不会暴露此错误，此明显不同的现象，为问题的分析提供了一个方向
> > 后来就逐渐怀疑到父子进程树`LD_LIBRARY_PATH`环境变量的传递上

# 解决方案
+ 局部解决
+ + 涉及运行`shell`系统命令，主动清空`LD_LIBRARY_PATH`环境变量，以便于使用系统默认路径
+ + 根据部署环境不同，对齐产品应用环境依赖，避免环境依赖上的版本差异
> 可以根据与其它应用的冲突情况，在私有加载路径，或全局路径上进行替换。
> > 在优良的冲突策略下，对全局路径上的依赖进行替换，似乎更可取
+ 系统性解决
+ + `docker`最优选解决方案
> 如果业务复杂到一定程度，`docker`几乎是最优选的解决方案，涉及依赖库在`docker`环境中完整提供，不单保持了环境的一致性，而且使得应用间具有独立性
> > 同时建议编译环境与运行环境保持一致性，避免`glibc`潜在的一些兼容性问题