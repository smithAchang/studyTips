以前一直觉得对于`HashTable`，如果选用的它的模数，尽量选择素数或质数，但，深入考察这个问题后，觉得这个认识有待商榷

# 哈希表用途
在哈希`key`通过散列函数可以与查找位置有接近`O(1)`的效率时，则相比较于树型索引数据结构，就获得更高的效率。其它场景，则需要根据索引类型的不同，进行具体选择评判。

天下无免费的午餐，在问题出现等概率的情况下，某个解决方案如果有一半适合，则有另外一半是不适合的。

那么面对的`key`值概率空间到底是什么样子的呢？是需要深入考究的问题，是否存在某种模式或规律？！

# 哈希表的装填因子
```c
  float a = records/hashTableLen
```

> 直观上来看，当表中填入的记录数一定的情况下， 哈希表的长度越长，装填因子就越小，这样冲突的概率就越小。


## 具体阐释例子
假设`hash`表的散列函数，通常使用取模的办法。

如果总共的记录数是`char`空间最大值，即256，而且记录的`key`值在`char`空间中平均分布，则可以看出，如果以哈希表长度来取模，则哈希表的长度决定了冲突程度的大小。

__注__:
  + 哈希表长度也并非无限，特别是`key`空间巨大时，树形索引可能更合适
  + 哈希表长度增长到一定程度，增益基本上消失，需要针对`key`空间进行合理选择，例如，记录数的一半
  + 针对不同场景需要不同的散列函数，莫要以一种散列函数包打天下

# 模数的新认识
在取模操作为散列函数的情况下，一般以哈希表的长度作为模数，但是选择质数，或其它数字是没有区别的！

其原因在于:
+ 取模操作的结果为不大于模数的值
+ 对于大于模数的值，无论是质数，还是其它数，都存在其从自然数1开始的倍数，这点上是没有区别的。

**重要还是，模数自身所形成的小于模数的空间大小，也决定了装填因子**

# 取模的快速运算
在`C`语言中，存在`%`取模操作符，但从机器底层来看，取模操作比较耗费时间。而如果模数是**2**的幂次，则取模操作，可以用快速的二进制位比特操作代替。
```c
    if(b == power(2, n))
       a % b = a & (b -1)  
```

# 结论
> 哈希表的模数尽量选择**2**的幂次，作为模数，取模操作时采用`&`的比特位操作进行平替！
